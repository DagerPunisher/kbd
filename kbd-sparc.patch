--- kbd-1.08/man/man8/kbdrate.8.jj	Tue Apr 17 11:07:57 2001
+++ kbd-1.08/man/man8/kbdrate.8	Tue Apr 17 11:08:24 2001
@@ -22,7 +22,7 @@
 without any options will reset the repeat rate to 10.9 characters per second (cps)
 and the delay to 250 milliseconds (ms) for Intel- and M68K-based systems.
 These are the IBM defaults. On SPARC-based systems it will reset the repeat rate
-to 5 cps and the delay to 200 ms.
+to 20 cps and the delay to 200 ms.
 
 .SH OPTIONS
 .TP
@@ -66,3 +66,5 @@
 .I /etc/rc.local
 .br
 .I /dev/port
+.br
+.I /dev/kbd
--- kbd-1.08/src/kbdrate.c.jj	Tue Apr 17 11:06:19 2001
+++ kbd-1.08/src/kbdrate.c	Tue Apr 17 11:07:30 2001
@@ -104,8 +11,11 @@
 
 static int
 KDKBDREP_ioctl_ok(double rate, int delay, int silent) {
+#ifndef __sparc__
 	/* This ioctl is defined in <linux/kd.h> but is not
-	   implemented anywhere - must be in some m68k patches. */
+	   implemented anywhere - must be in some m68k patches.
+	   Cannot blindly try unimplemented ioctls on sparc64 -
+	   the 32<->64bit transition layer does not like it. */
 	struct kbd_repeat kbdrep_s;
 
 	/* don't change, just test */
@@ -150,6 +153,10 @@
 			rate, kbdrep_s.delay );
 
 	return 1;			/* success! */
+
+#else
+	return 0;
+#endif /* __sparc__ */
 }

 static int
@@ -164,10 +171,16 @@
 		exit( 1 );
 	}
 
+#ifdef __sparc__
+	kbdrate_s.rate = (int) (rate + 0.5);  /* round up */
+	if (kbdrate_s.rate > 50)
+		kbdrate_s.rate = 50;
+#else
 	kbdrate_s.period = (int) (rate + 0.5);  /* round up */
-	kbdrate_s.delay = delay * HZ / 1000;  /* convert ms to Hz */
 	if (kbdrate_s.period > 50)
 		kbdrate_s.period = 50;
+#endif
+	kbdrate_s.delay = delay * HZ / 1000;  /* convert ms to Hz */
 
 	if (ioctl( fd, KIOCSRATE, &kbdrate_s )) {
 		perror( "ioctl(KIOCSRATE)" );
@@ -176,8 +189,13 @@
 	close( fd );
 
 	if (!silent)
+#ifdef __sparc__
+		printf( "Typematic Rate set to %d cps (delay = %d ms)\n",
+			kbdrate_s.rate, kbdrate_s.delay * 1000 / HZ );
+#else
 		printf( "Typematic Rate set to %d cps (delay = %d ms)\n",
 			kbdrate_s.period, kbdrate_s.delay * 1000 / HZ );
+#endif
 
 	return 1;
 #else /* no KIOCSRATE */
@@ -188,7 +206,7 @@
 int
 main( int argc, char **argv ) {
 #ifdef __sparc__
-	double      rate = 5.0;      /* Default rate */
+	double      rate = 20.0;     /* Default rate */
 	int         delay = 200;     /* Default delay */
 #else
 	double      rate = 10.9;     /* Default rate */
@@ -238,8 +256,9 @@
 		return 0;
 
 
-	/* The ioport way */
+	/* The ioport way - will crash on sparc */
 
+#ifndef __sparc__
 	for (i = 0; i < RATE_COUNT; i++)
 		if (rate * 10 >= valid_rates[i]) {
 			value &= 0x60;
@@ -285,5 +304,7 @@
 			valid_rates[value & 0x1f] / 10.0,
 			valid_delays[ (value & 0x60) >> 5 ] );
 
+#endif
+
 	return 0;
 }
